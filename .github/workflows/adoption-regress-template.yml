name: adoption-regress-template

on:
  workflow_dispatch:
    inputs:
      fixture_runpack_path:
        description: "Path to fixture runpack.zip"
        required: false
        default: "fixtures/run_demo/runpack.zip"
      config_path:
        description: "Path to gait regress config"
        required: false
        default: "gait.yaml"
      source_run:
        description: "Run ID used when fixture restore fallback is needed"
        required: false
        default: "run_demo"
  workflow_call:
    inputs:
      fixture_runpack_path:
        required: false
        type: string
        default: "fixtures/run_demo/runpack.zip"
      config_path:
        required: false
        type: string
        default: "gait.yaml"
      source_run:
        required: false
        type: string
        default: "run_demo"
    outputs:
      regress_status:
        description: "regress_result status field"
        value: ${{ jobs.regress.outputs.regress_status }}
      regress_exit_code:
        description: "stable regress exit code"
        value: ${{ jobs.regress.outputs.regress_exit_code }}
      top_failure_reason:
        description: "top failure reason from regress result"
        value: ${{ jobs.regress.outputs.top_failure_reason }}
      next_command:
        description: "next command hint from regress result"
        value: ${{ jobs.regress.outputs.next_command }}
      artifact_root:
        description: "artifact directory path"
        value: ${{ jobs.regress.outputs.artifact_root }}

permissions:
  contents: read
  actions: write

jobs:
  regress:
    runs-on: ubuntu-latest
    outputs:
      regress_status: ${{ steps.regress_parse.outputs.regress_status }}
      regress_exit_code: ${{ steps.regress_run.outputs.exit_code }}
      top_failure_reason: ${{ steps.regress_parse.outputs.top_failure_reason }}
      next_command: ${{ steps.regress_parse.outputs.next_command }}
      artifact_root: ${{ steps.paths.outputs.artifact_root }}
    env:
      FIXTURE_RUNPACK_PATH: ${{ inputs.fixture_runpack_path || github.event.inputs.fixture_runpack_path || 'fixtures/run_demo/runpack.zip' }}
      CONFIG_PATH: ${{ inputs.config_path || github.event.inputs.config_path || 'gait.yaml' }}
      SOURCE_RUN: ${{ inputs.source_run || github.event.inputs.source_run || 'run_demo' }}
      ARTIFACT_ROOT: gait-out/adoption_regress
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Build gait
        shell: bash
        run: go build -o ./gait ./cmd/gait

      - name: Resolve template paths
        id: paths
        shell: bash
        run: |
          mkdir -p "${ARTIFACT_ROOT}"
          {
            echo "artifact_root=${ARTIFACT_ROOT}"
            echo "fixture_runpack=${FIXTURE_RUNPACK_PATH}"
            echo "config_path=${CONFIG_PATH}"
            echo "source_run=${SOURCE_RUN}"
          } >> "$GITHUB_OUTPUT"

      - name: Restore deterministic fixture
        id: restore_fixture
        shell: bash
        run: |
          : "${FIXTURE_RUNPACK_PATH:?FIXTURE_RUNPACK_PATH must be set}"
          : "${CONFIG_PATH:?CONFIG_PATH must be set}"
          : "${SOURCE_RUN:?SOURCE_RUN must be set}"
          fixture_runpack="${FIXTURE_RUNPACK_PATH}"
          config_path="${CONFIG_PATH}"

          if [[ -f "${fixture_runpack}" && -f "${config_path}" ]]; then
            echo "using existing fixture=${fixture_runpack} config=${config_path}"
          else
            echo "fixture/config missing; generating deterministic fallback from ${SOURCE_RUN}"
            ./gait demo
            ./gait regress init --from "${SOURCE_RUN}" --json > "${ARTIFACT_ROOT}/regress_init_result.json"

            # Re-point fixture verification to generated fallback artifacts.
            if [[ -f "fixtures/${SOURCE_RUN}/runpack.zip" ]]; then
              fixture_runpack="fixtures/${SOURCE_RUN}/runpack.zip"
            elif [[ -f "fixtures/run_demo/runpack.zip" ]]; then
              fixture_runpack="fixtures/run_demo/runpack.zip"
            else
              echo "fallback did not produce a fixture runpack for source_run=${SOURCE_RUN}" >&2
              exit 1
            fi
          fi

          echo "fixture_runpack_effective=${fixture_runpack}" >> "$GITHUB_OUTPUT"

      - name: Run regress (capture stable exit code)
        id: regress_run
        shell: bash
        run: |
          set +e
          ./gait regress run --json --junit="${ARTIFACT_ROOT}/junit.xml" > "${ARTIFACT_ROOT}/regress_result.json"
          status=$?
          set -e

          echo "exit_code=${status}" >> "$GITHUB_OUTPUT"

          if [[ "${status}" -ne 0 && "${status}" -ne 5 ]]; then
            echo "unexpected regress exit code: ${status}" >&2
            exit "${status}"
          fi

      - name: Verify fixture pack integrity
        shell: bash
        run: |
          fixture_runpack="${{ steps.restore_fixture.outputs.fixture_runpack_effective }}"
          : "${fixture_runpack:?effective fixture runpack path must be set}"
          ./gait pack verify "${fixture_runpack}" --json > "${ARTIFACT_ROOT}/pack_verify_fixture.json"
          python3 - "${ARTIFACT_ROOT}/pack_verify_fixture.json" <<'PY'
          import json
          import sys
          from pathlib import Path

          payload = json.loads(Path(sys.argv[1]).read_text(encoding="utf-8"))
          if payload.get("ok") is not True:
              raise SystemExit(f"pack verify expected ok=true, got: {payload}")
          PY

      - name: Parse regress result fields
        id: regress_parse
        shell: bash
        run: |
          python3 - "${ARTIFACT_ROOT}/regress_result.json" <<'PY'
          import json
          import os
          import sys
          from pathlib import Path

          payload = json.loads(Path(sys.argv[1]).read_text(encoding="utf-8"))

          def sanitize(value: object) -> str:
              text = str(value).replace("\n", " ").strip()
              if not text:
                  return "none"
              return text

          status = sanitize(payload.get("status", "unknown"))
          top_failure_reason = sanitize(payload.get("top_failure_reason", "none"))
          next_command = sanitize(payload.get("next_command", "none"))
          artifact_paths = payload.get("artifact_paths")
          if isinstance(artifact_paths, list):
              artifact_paths_text = ", ".join(str(item) for item in artifact_paths if str(item).strip())
          else:
              artifact_paths_text = ""
          artifact_paths_text = sanitize(artifact_paths_text or "none")

          output_path = os.environ.get("GITHUB_OUTPUT", "")
          if not output_path:
              raise SystemExit("GITHUB_OUTPUT is not set")
          with Path(output_path).open("a", encoding="utf-8") as out:
              out.write(f"regress_status={status}\n")
              out.write(f"top_failure_reason={top_failure_reason}\n")
              out.write(f"next_command={next_command}\n")
              out.write(f"artifact_paths={artifact_paths_text}\n")
          PY

      - name: Endpoint policy fixture checks
        shell: bash
        run: |
          ./gait policy test examples/policy/endpoint/allow_safe_endpoints.yaml examples/policy/endpoint/fixtures/intent_allow.json --json
          set +e
          ./gait policy test examples/policy/endpoint/block_denied_endpoints.yaml examples/policy/endpoint/fixtures/intent_block.json --json
          block_status=$?
          ./gait policy test examples/policy/endpoint/require_approval_destructive.yaml examples/policy/endpoint/fixtures/intent_destructive.json --json
          approval_status=$?
          set -e
          if [[ "$block_status" -ne 3 ]]; then
            echo "endpoint block fixture exit mismatch: $block_status"
            exit 1
          fi
          if [[ "$approval_status" -ne 4 ]]; then
            echo "endpoint approval fixture exit mismatch: $approval_status"
            exit 1
          fi

      - name: Skill provenance verification checks
        shell: bash
        run: |
          bash scripts/test_skill_supply_chain.sh

      - name: Publish regress summary
        if: always()
        shell: bash
        run: |
          {
            echo "## Adoption Regress Summary"
            echo ""
            # shellcheck disable=SC2006
            echo "- status: `${{ steps.regress_parse.outputs.regress_status }}`"
            # shellcheck disable=SC2006
            echo "- exit_code: `${{ steps.regress_run.outputs.exit_code }}`"
            # shellcheck disable=SC2006
            echo "- top_failure_reason: `${{ steps.regress_parse.outputs.top_failure_reason }}`"
            # shellcheck disable=SC2006
            echo "- next_command: `${{ steps.regress_parse.outputs.next_command }}`"
            # shellcheck disable=SC2006
            echo "- artifact_root: `${ARTIFACT_ROOT}`"
            # shellcheck disable=SC2006
            echo "- artifact_paths: `${{ steps.regress_parse.outputs.artifact_paths }}`"
            # shellcheck disable=SC2006
            echo "- pack_verify: `${ARTIFACT_ROOT}/pack_verify_fixture.json`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload regress artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gait-regress-artifacts
          path: |
            gait-out/adoption_regress/regress_result.json
            gait-out/adoption_regress/junit.xml
            gait-out/adoption_regress/regress_init_result.json
            gait-out/adoption_regress/pack_verify_fixture.json
            gait.yaml
            fixtures/

      - name: Enforce stable regress exit code contract
        if: always()
        shell: bash
        run: |
          status="${{ steps.regress_run.outputs.exit_code }}"
          if [[ "$status" == "0" ]]; then
            echo "regression passed"
            exit 0
          fi
          if [[ "$status" == "5" ]]; then
            echo "regression failed with stable exit code 5"
            exit 5
          fi
          echo "unexpected regress exit code: ${status}"
          exit 1
